generator int expr(int x, int y, int z, int p, int q, int bnd){
	assert bnd > 0;
	generator int sum(){
		return {| ((x | y | z | p | q) +  (x | y | z | p | q | ??) ) | ?? |};
	}
	if(??) { return sum(); }
	else { return {| expr(x,y,z,p,q,bnd-1) (* | /) sum() |}; }
}


generator void updateLoc(int n, ref int[n] out, int[n] xs, int[n] ys, int[n] zs, int[n] qs, int at, int bound) {
  out[at] = expr(at, xs[at], ys[at], zs[at], qs[at], bound);
}

boolean midPoint(int n, int[n] x, int[n] y, int[n] mid, int[n] sum) {
  boolean out = true;
  for (int i = 0; i < n; ++i) {
    out = out && (x[i] + y[i])/2 == mid[i];
    out = out && x[i] + y[i] == sum[i];
  }
	return out;
}

void buildExpenses(int n, ref int[n] x, ref int[n] y, ref int[n] mid, ref int[n] sum) {
  for (int i = 0; i < n; ++i) {
    x[i] = i;
    if (i % 2 == 0) {
      y[i] = 5 * i;
      mid[i] = 3 * i;
      sum[i] = 6 * i;
    } else {
      y[i] = - 5 * i;
      mid[i] = - 2 * i;
      sum[i] = -4 * i;
    }
    
  }
}

void buildColors(int n, ref int[n] vals, ref boolean[n] colors) {
  for (int i = 0; i < n; ++i) {
    if (vals[i] < 0) {
      colors[i] = false;
    } else {
      colors[i] = true;
    }
  }
}

generator boolean bexpr(int x, int y, boolean c, int bound) {
  assert bound >0 ;
  generator boolean term() {
    return {| (x | y) (> | < | <= | >=) (x | y | ??) |};
  }
  if (??) {return {| true | false | c | term() |}; }
  else {
    return term() && bexpr(x, y, c, bound-1);
  }
}

generator void fixColors(int n, ref int[n] vs, ref boolean[n] cs) {
  for (int i = 0; i < n; ++i) {
    boolean guard = bexpr(i, vs[i], cs[i], 1);
    if (guard) {
      cs[i] = bexpr(i, vs[i], cs[i], 1);
    } else {
      cs[i] = bexpr(i, vs[i], cs[i], 1);
    }
  }
}

void assumeColors(int n, ref int[n] vals, ref boolean[n] colors) {
  for (int i = 0; i < n; ++i) {
    if (vals[i] < 0) {
      assume colors[i] == false;
    } else {
      assume colors[i] == true;
    }
  }
}

void assertColors(int n, ref int[n] vals, ref boolean[n] colors) {
  for (int i = 0; i < n; ++i) {
    if (vals[i] < 0) {
      assert colors[i] == false;
    } else {
      assert colors[i] == true;
    }
  }
}

harness void sketch (int i1, int other1, int i2, int other2, int i3, int other3, int other4, int other5) {
  int n = 3;
  int[n] x;
  int[n] y; 
  int[n] mid;
  int[n] sum;
  boolean[n] colors;

  buildExpenses(n, x, y, mid, sum);
  buildColors(n, sum, colors);

	assume midPoint(n, x, y, mid, sum);
  assumeColors(n, sum, colors);
  /*
  procedure addRowMeThem() {
    let i: int;
    let val: int;
    let val2: int;
    for (x: int, t: int) with idx in (me, them) {
      if (idx == i) {
        x = val;
        t = val2;
      }
    }
  }
  */

  assume 0 <= i1 && i1 < n;
  
	x[i1] = other1;
  y[i1] = other2;
	updateLoc(n,mid,x,y,mid,sum,i1,2);
  updateLoc(n,sum,x,y,mid,sum,i1,2);
  fixColors(n, sum, colors);

	assert midPoint(n, x, y, mid, sum);
  assertColors(n, sum, colors);

  /*
  procedure addRowMeSum() {
    
    let val: int;
    let val2: int;
    let i: int;
    for (x: int, t: int) with idx in (me, sum) {
      if (idx == i) {
        x = val;
        t = val2;
      }
    }
  }
  */
  

  assume 0 <= i2 && i2 < n;

	x[i2] = other3;
  sum[i2] = other4;
	updateLoc(n,y,x,y,mid,sum,i2,2);
  updateLoc(n,mid,x,y,mid,sum,i2,2);
  fixColors(n, sum, colors);

	assert midPoint(n, x, y, mid,sum);
  assertColors(n, sum, colors);

  

  /*

  procedure adjustThemEntry() {

    let val: int;
    let i: int;
    for (x: int, t: int) with idx in (them, sum) {
      if (idx == i) {
        x = val;
        t = t;
      }
    }
  }
  */

  assume 0 <= i3 && i3 < n;

	y[i3] = other4;
  sum[i3] = sum[i3];
	updateLoc(n,x,x,y,mid,sum,i3,2);
  updateLoc(n,mid,x,y,mid,sum,i3,2);
  fixColors(n, sum, colors);

	assert midPoint(n, x, y, mid,sum);
  assertColors(n, sum, colors);

	
}