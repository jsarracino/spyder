void incr ( int n, ref int[n] out ) {
	for (int i = 0; i < n; ++i) {
		out[i] = out[i] + 1;
	}
}


generator int[n] arrExpr(int n, int[n] it, int[n] p, int[n] q, int b) {
	int[n] output;
	for(int i=0; i<n; i++){
		output[i] = expr(it[i], p[i], q[i], i, b);
		//output[i] = it[i] + 1;
	}
	return output;
}

generator int expr(int x, int y, int z, int k, int bnd){
	assert bnd > 0;
	generator int sum(){
		return {| x | y | z | k |} + {| x | y | z | k | ?? |};
	}
	if(??) { return sum(); }
	else { return sum() * expr(x,y,z,k,bnd-1); }
}

void midPointSpec(int n, int[n] x, int[n] y, int[n] mid) {
	for (int i = 0; i < n; ++i) {
		assert x[i] + y[i] == 2 * mid[i];
	}
}

void midpointAssume(int n, int[n] x, int[n] y, int[n] mid) {
	for (int i = 0; i < n; ++i) {
		assume x[i] + y[i] == 2 * mid[i];
	}
}
 
void distinctSpec(int n, int[n] l, int[n] r) {
	for (int i = 0; i < n; ++i) {
		assert l[i] != r[i];
	}
}
void distinctAssume(int n, int[n] l, int[n] r) {
	for (int i = 0; i < n; ++i) {
		assume l[i] != r[i];
	}
}

void buildMidpoint(int n, ref int[n] x, ref int[n] y, ref int[n] mid) {
	for (int i = 1; i < n + 1; ++i) {
		x[i-1] = i;
		mid[i-1] = 2 * i;
		y[i-1] = 3 * i;
	}
}

harness void sketch () {
	int n = 3;
	int[n] x;
	int[n] y;
	int[n] mid;
	buildMidpoint(n, x, y, mid);

	midpointAssume(n, x, y, mid);
	distinctAssume(n, x, y);

	incr(n, x);

	int[n] m1 = arrExpr(n,x,y,mid,1);
	int[n] y1 = arrExpr(n,x,y,m1,1);
	distinctSpec(n, x, y1);
	midPointSpec(n, x, y1, m1);

	mid = m1;
	y = y1;

	incr(n, mid);

	int[n] x1 = arrExpr(n,x,y,mid,1);
	y1 = arrExpr(n,x1,y,mid,1);
	distinctSpec(n, x1, y1);
	midPointSpec(n, x1, y1, mid);

	x = x1;
	y = y1;

	incr(n, y);

	x1 = arrExpr(n,x,y,mid,1);
	m1 = arrExpr(n,x1,y,mid,1);
	distinctSpec(n, x1, y);
	midPointSpec(n, x1, y, m1);
}